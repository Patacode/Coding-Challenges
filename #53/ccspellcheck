#!/usr/bin/env ruby
# frozen_string_literal: true

$LOAD_PATH.unshift File.expand_path('lib', __dir__)

require 'optparse'
require 'benchmark'

require 'bloom_filter'

options = {}

OptionParser.accept(:text_file) do |filepath|
  err_msg = "- filepath #{filepath.inspect} must have a .txt extension"
  err_msg2 = "- filepath #{filepath.inspect} does not exist"
  raise OptionParser::InvalidArgument, err_msg unless filepath.end_with?('.txt')
  raise OptionParser::InvalidArgument, err_msg2 unless File.exist?(filepath)

  filepath
end

parser = OptionParser.new do |opts|
  opts.banner = 'Usage: ccspellcheck [options]'

  opts.on('-h', '--help', 'prints this help') do
    puts opts
    exit
  end

  opts.on(
    '-b',
    '--build DICTIONARY_FILE',
    :text_file,
    'Build bloom filter'
  ) do |filepath|
    options[:dictionary] = filepath
  end
end

ARGV.empty? ? parser.parse('-h') : parser.parse!

dictionary = options[:dictionary]

element_count = File.open(dictionary) do |file|
  file.each_line.count
end

bf = nil
Benchmark.bm do |x|
  x.report('add(0.01)') do
    bf = BloomFilter.new(element_count)
    chunk_size = 1024 * 1024 # 1 Mib
    last_line = ''
    File.open(dictionary) do |file|
      until file.eof?
        chunk = file.read(chunk_size)
        chunk_lines = chunk.split("\n")

        partial_line_detected = !chunk.end_with?("\n")

        bf << "#{last_line}#{chunk_lines[0]}"
        chunk_lines[1..-2].each { |line| bf << line }

        last_line = chunk_lines[-1]
        bf << last_line unless partial_line_detected
      end
    end
  end

  x.report('save_to_file(0.01)') do
    bf.save_to_file('result')
  end

  x.report('add(0.1)') do
    bf = BloomFilter.new(element_count, epsilon: 0.1)
    chunk_size = 1024 * 1024 # 1 Mib
    last_line = ''
    File.open(dictionary) do |file|
      until file.eof?
        chunk = file.read(chunk_size)
        chunk_lines = chunk.split("\n")

        partial_line_detected = !chunk.end_with?("\n")

        bf << "#{last_line}#{chunk_lines[0]}"
        chunk_lines[1..-2].each { |line| bf << line }

        last_line = chunk_lines[-1]
        bf << last_line unless partial_line_detected
      end
    end
  end

  x.report('save_to_file(0.1)') do
    bf.save_to_file('result2')
  end
end
