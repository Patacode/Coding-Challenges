#!/usr/bin/env ruby

$LOAD_PATH.unshift File.expand_path('lib', __dir__)

require 'optparse'
require 'bloom_filter'

options = {}

OptionParser.accept(:text_file) do |filepath|
  err_msg = "- filepath #{filepath.inspect} must have a .txt extension"
  err_msg2 = "- filepath #{filepath.inspect} does not exist"
  raise OptionParser::InvalidArgument, err_msg unless filepath.end_with?('.txt')
  raise OptionParser::InvalidArgument, err_msg2 unless File.exist?(filepath)

  filepath
end

parser = OptionParser.new do |opts|
  opts.banner = 'Usage: ccspellcheck [options]'

  opts.on("-h", "--help", "prints this help") do
    puts opts
    exit
  end

  opts.on(
    '-b',
    '--build DICTIONARY_FILE',
    :text_file,
    'Build bloom filter'
  ) do |filepath|
    options[:dictionary] = filepath
  end
end

ARGV.empty? ? parser.parse("-h") : parser.parse!

dictionary = options[:dictionary]
bf = BloomFilter.new(dictionary)

chunk_size = 1024 * 1024 # 1 Mib
last_line = ''
File.open(dictionary) do |file|
  until file.eof?
    chunk = file.read(chunk_size)
    chunk_lines = chunk.split("\n")
    p chunk_lines

    partial_line_detected = !chunk.end_with?("\n")

    bf << "#{last_line}#{chunk_lines[0]}"
    chunk_lines[1..-2].each { |line| p line; bf << line }

    last_line = chunk_lines[-1]
    bf << last_line unless partial_line_detected
  end
  file.each_line { |line| bf << line.strip }
end

bf.save_to_file('result')
